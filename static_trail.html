<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLITCH.EXE - TRAIL</title>
    <link href="style.css" rel="stylesheet" type="text/css" media="all">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1;
      }
    </style>
  </head>
  <body class="glitch">
    <div class="container">
      <h1>üë£ THE STATIC TRAIL üë£</h1>
      <p>You follow the buzzing tail of static. Bits of broken memories flicker‚Äîfaces, sounds, moments. You remember...something.<br><br>
      The trail ends at a firewall glowing red. It's alive. And it's watching you.<br><br>
      You reach out and touch the barrier. It ripples. A voice echoes: <em>"INTERFACE...OR...RETREAT?"</em></p>

      <div class="choices">
        <a href="hydra_synth.html">üåä Touch the firewall - INTERFACE</a>
        <a href="index.html">‚¨ÖÔ∏è Retreat - Restart</a>
    </div>
  </div>

  <script>
    let gridSize = 20; // Size of each square
    let cols, rows;
    let noiseScale = 0.08; // Controls the smoothness of waves
    let timeOffset = 0;
    let staticBurst = false;
    let burstTimer = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      cols = ceil(width / gridSize);
      rows = ceil(height / gridSize);
      noStroke();
    }

    function draw() {
      background(28, 28, 31); // Dark background

      // Occasional static bursts
      if (random(1) < 0.008) {
        staticBurst = true;
        burstTimer = 20;
      }

      if (burstTimer > 0) {
        burstTimer--;
        if (burstTimer === 0) staticBurst = false;
      }

      // Draw undulating pixel grid
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          let x = i * gridSize;
          let y = j * gridSize;

          // Create undulating wave pattern using Perlin noise
          let noiseVal = noise(
            i * noiseScale,
            j * noiseScale,
            timeOffset
          );

          // Add second layer of noise for more complex patterns
          let noiseVal2 = noise(
            i * noiseScale * 2 + 100,
            j * noiseScale * 2 + 100,
            timeOffset * 1.5
          );

          // Combine noise values
          let combinedNoise = (noiseVal + noiseVal2 * 0.5) / 1.5;

          // During static burst, add randomness
          if (staticBurst) {
            combinedNoise = random(1);
          }

          // Determine if square should be black or white
          let isWhite = combinedNoise > 0.5;

          // Draw the square
          if (isWhite) {
            fill(255, 255, 255, 200); // White with slight transparency
          } else {
            fill(0, 0, 0, 150); // Black with transparency
          }

          rect(x, y, gridSize, gridSize);

          // Add occasional flicker effect to individual squares
          if (!staticBurst && random(1) < 0.02) {
            fill(random(1) > 0.5 ? 255 : 0);
            rect(x, y, gridSize, gridSize);
          }
        }
      }

      // Increment time for animation
      timeOffset += 0.015;
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      cols = ceil(width / gridSize);
      rows = ceil(height / gridSize);
    }
  </script>
  </body>
</html>